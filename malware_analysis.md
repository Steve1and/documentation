# Reverse Engineering and Malware Analysis Notes
***

## Resources

https://www.virustotal.com
https://nvd.nist.gov/
https://docs.microsoft.com/en-us/sysinternals/
https://www.sans.org/blog/alternate-data-streams-overview/
https://home.unicode.org/
https://cuckoosandbox.org
https://www.fireeye.com/services/freeware/apatedns.html
https://x64dbg.com/#start
https://retdec.com
https://godbolt.org
https://upx.github.io/
http://www.openrce.org
https://llvm.org
http://www.aspack.com

***

## Basic Malware Analysis

Any software that does something that causes detriment to the user, computer, or network can be considered *malware*.

The purpose of malware analysis is usually to provide the information needed to respond to a network intrusion. When analyzing suspected malware, the goal will typically be to determine exactly what a particular suspect binary can do, how to detect it on the network, and how to measure and contain its damage.

*Host-based signatures*, or indicators, are used to detect malicious code on victim computers.

*Network signatures* are used to detect malicious code by monitoring network traffic.

### Malware Analysis Techniques

*Static analysis* involves examining the malware without running it. *Dynamic analysis* involves running the malware.
- **Basic Static Analysis**: consists of examining the executable file without viewing the actual instructions.
- **Basic Dynamic Analysis**: involves running the malware and observing its behavior on the system in order to remove the infection, produce effective signatures, or both.
- **Advanced Static Analysis**: consists of reverse-engineering the malware's internals by loading the executable into a disassembler and looking at the program instructions in order to discover what the program does.
- **Advanced Dynamic Analysis**: Advanced dynamic analysis uses s debugger to examine the internal state of a running malicious executable.

### Types of Malware

- **Backdoor**: Malicious code that installs itself onto a computer to allow the attacker access.
- **Botnet**: Similar to a backdoor, in that it allows the attacker access to the system, but all computers infected with the same botnet receive the same instructions from a single command-and-control server.
- **Downloader**: Malicious code that exists only to download other malicious code.
- **Information-stealing malware**: Malware that collects information from a victim's computer and usually sends it to the attacker.
- **Launcher**: Malicious program used to launch other malicious programs.
- **Rootkit**: Malicious code designed to conceal the existence of other code.
- **Scareware**: Malware designed to frighten an infected user into buying something.
- **Spam-sending malware**: Malware that infects a user's machine and then uses that machine to send spam.
- **Worm or virus**: Malicious doe that can copy itself and infect additional computers.
***

## Basic Static Techniques

1. **Antivirus Scanning**: used to identify a potential piece of malware using a database of identifiable pieces of known suspicious code (*file signatures*), as well as behavioral and pattern-matching analysis (*heuristics*) to identify suspect files.
2. **Hashing**: running malicious software through a hashing program that produces a unique *hash* that identifies that malware (a sort of fingerprint).
  - Use MD5 or SHA-1
3. **Strings**: A string in a program is a sequence of characters such as "the". Both ASCII and Unicode formats store characters in sequences that end with a *NULL terminator* to indicate that the string is complete. ASCII strings use 1 byte per character, and Unicode uses 2 bytes per character.
  - Unicode uses two 0x00 bytes in a row for the NULL terminator.
  - The **Strings** program searches for a three-letter or greater sequence of ASCII and Unicode characters, followed by a string termination character.

### Packed and Obfuscated Malware

*Obfuscated* programs are ones whose execution the malware author has attempted to hide. *Packed* programs are a subset of obfuscated programs in which the malicious program is compressed and cannot be analyzed.
  - Packed and obfuscated code will often include at least the functions `LoadLibrary` and `GetProcAddress`, which are used to load and gain access to additional function.

**Packing Files**: When the packed program is run, a small wrapper program also runs to decompress the packed file and then run the unpacked file. When a packed program is analyzed statically, only the small wrapper program can be dissected.
  - One way to detect packed files is with the PEiD program.
  - The UPX packing program is typically used to pack software.
  - **NOTE**: Many PEiD plug-ins will run the malware executable without warning.

### Portable Executable File Format

The format of a file can reveal a lot about the program's functionality. The Portable Executable (PE) file format is used by Windows executables, object code, and DLLs.

*Imports* are functions used by one program that are actually stored in a different program. Code libraries can be connected to the main executable by *linking*.

**Static Linking**: when a library is statically linked to an executable, all code from that library is copied into the executable, which makes the executable grow in size.

**Runtime Linking**: Executables that use runtime linking connect to libraries only when that function is needed, not at program start, as with dynamically linked programs.

Several Windows functions allow programmers to import linked functions not listed in a program's file header. Of these, the two most commonly used are `LoadLibrary` and `GetProcAddress`, `LdrGetProcAddress` and `LdrLoadDll` are also used. `LoadLibrary` and `GetProcAddress` allow a program to access any function in any library on the system, which means that when these functions are used, you can't tell statically which functions are being linked to by the suspect program.

The Dependency Walker program (http://www.dependencywalker.com), lists only dynamically linked functions in an executable.

Executables can import functions by ordinal instead of name. When importing a function by ordinal, the name of the function never appears in the original executable, and it can be harder for an analyst to figure out which function is being used.

**Common DLLs**

| DLL | Description |
| --- | ----------- |
| kernel32.dll | This is a very common DLL that contains core functionality, such as access and manipulation of memory, files, and hardware. |
| Advapi32.dll | This DLL provides access to advanced core Windows components such as the Service Manager and Registry. |
| User32.dll | This DLL contains all the user-interface components, such as buttons, scroll bars, and components for controlling and responding to user actions. |
| Gdi32.dll | This DLL contains functions for displaying and manipulating graphics. |
| Ntdll.dll | This DLL is the interface to the Windows kernel. Exectuables generally do not import this file directly, although it is always imported indirectly by Kernel32.dll. If an executable imports this file, it means that the author intended to use functionality not normally available to Windows programs. Some tasks, such as hiding functionality or manipulating processes, will use this interface. |
| WSock32.dll and Ws2_32.dll | These are networking DLLs. A program that accesses either of these most likely connects to a network or performs network-related tasks. |
| Wininet.dll | This DLL contains higher-level networking functions that implement protocols such as FTP, HTTP, and NTP. |

**Function Naming Conventions**: When Microsoft updates a function and the new function is incompatible with the old one, Microsoft continues to support the old function. The new function is given the same name as the old function, with an added `Ex` suffix. Functions that have been significantly updated twice have two `Ex` suffixes in their names. Many functions that take strings as parameters include an A or a W at the end of their names. This indicates that the function accepts a string parameter and that there are two different versions of the function: one for ASCII strings and one for wide character strings.

In order to run a program as a service, you must first define a `ServiceMain` function. The presence of an exported function called `ServiceMain` tells you that the malware runs as part of a service.

The function `SetWindowsHookEx` is commonly used in spyware and is the most popular way that keyloggers receive keyboard inputs.

`Software\Microsoft\Windows\CurrentVersion\Run`, which is a registry key (commonly used by malware) that controls which programs are automatically run when Windows starts up.

The PE file format contains a header followed by a series of sections. The header contains metadata about the file itself.

| PE Section | Description |
| ---------- | ----------- |
| .text | Contains the executable code |
| .rdata | Holds read-only data that is globally accessible within the program. |  
| .data | Stores global data access throughout the program |
| .idata | Sometimes present and stores the import function information; if this section is not present, the import function information is stored in the `.rdata` section |
| .edata | Sometimes present and stores the export function information; if this section is not present, the export function information is stored in the `.rdata` section. |
| .pdata | Present only in 64-bit executables and stores exception-handling information. |
| .rsrc | Stores resources needed by the executable |
| .reloc | Contains information for relocation of library files. |

**Information in the PE Header**

| Field | Information Revealed |
| ----- | -------------------- |
| Imports | Functions from other libraries that are used by the malware |
| Exports | Functions in the malware that are meant to be called by other programs or libraries. |
| Time Date Stamp | Time when the program was compiled |
| Sections | Names of sections in the file and their sizes on disk and in memory. |
| Subsystem | Indicates whether the program is a command-line or GUI application. |
| Resources | Strings, icons, menus, and other information included in the file. |

***

## Creating a Malware Analysis Virtual Environment

*Host-only networking*, a feature that creates a separate private LAN between the host OS and the guest OS, is commonly used for malware analysis. VMware creates a virtual network adapter in the host and virtual machines, and connects the two without touching the host's physical network adapter.

Using multiple virtual machines, they can be linked by a LAN but disconnected from the Internet and host machine, so that the malware is connected to a network, but the network isn't connected to anything important. The VM's are connected to the same VMNet virtual switch. In this case, the host machine is still connected to the external network, but not to the machine running the malware. When using more than one virtual machine for analysis, they can be combined as *virtual machine teams*. These teams can manage their power and network settings together. To create a new virtual machine team in VMWare, choose: `File` -> `New` -> `Team`.

The most common way to connect a virtual machine to the Internet using VMware is with a *bridged network adapter*, which allows the virtual machine to be connected to the same network interface as the physical machine. Another way to connect malware running on a virtual machine to the Internet is to use VMware's Network Address Translation (NAT) mode. NAT mode shares the host's IP connection to the Internet. The host acts like a router and translates all requests from the virtual machine so that they come from the host's IP address.
- Choose `VM` -> `Settings` -> `USB Controller` and uncheck the `Automatically connect new USB devices` checkbox to prevent USB devices from being connected to the virtual machine.

After the host OS is installed along with malware analysis tools, and the newtork has been configured, take a snapshot. Use it as a base to return to as a clean image.

Anoth3er way to transfer data between a VM and the host machine is with VMware's shared folders. A *shared folder* is accessible from both the host and the guest OS, similar to a shared Windows folder.
***

## Basic Dynamic Analysis

*Dynamic analysis* is any examination performed after executing malware.

Malware can be run by either double-clicking it as an executable or running it from the command line. If it is a DLL, the program `rundll32.exe` is included with all modern versions of Windows. It provides a container for running a DLL using this syntax: `rundll32.exe DLLname, Export arguments`. The *Export* value must be a function name or ordinal selected from the exported function table in the DLL.

Because malicious DLLs frequently run most of their code in `DLLMain` (called from the DLL entry point), and because `DLLMain` is executed whenever the DLL is loaded, you can often get information dynamically by forcing the DLL to load using `rundll32.exe`. Alternatively, you can even turn a DLL into an executable by modifying the PE header and changing its extension to force Windows to load the DLL as it would an executable. To modify the PE header, wipe the `IMAGE_FILE_DLL` (0x2000) flag from the Characteristics field in the `IMAGE_FILE_HEADER`.

DLL malware may also need to be installed as a service, sometimes with a convenient export such as `InstallService`. For example:
- `rundll32.exe baddll.dll, InstallService ServiceName`
- `net start ServiceName`

When you see a `ServiceMain` function without a convenient exported function such as `Install` or `InstallService`, you may need to install the service manually. You can do this by using the WIndows `sc` command or by modifying the registry for an unused service, and then using `net start` on that service. The service entries are located in the registry at `HKLM\SYSTEM\CurrentControlSet\Services`.

### Monitoring with Process Monitor

Process Monitor, or procmon, is an advanced monitoring tool for Windows that provides a way to monitor certain registry, file system, network, process, and thread activity.
- Procmon monitors all system calls it can gather as soon as it is run.
- You can set procmon to filter on one executable running on the system.
- To set a filter, choose `Filter` -> `Filter` to open the Filter menu.
- If your malware runs at boot time, use procmon's boot logging options to install procmon as a startup driver to capture startup events.

### Viewing Processes with Process Explorer

Process Explorer monitors the processes running on a system and shows them in a tree structure that displays child and parent relationships.
- One particularly useful Process Explorer feature is the Verify button on the Image tab. Click this button to verify that the image on disk is, in fact, the Microsoft signed binary.
- The Verify button verifies the image on disk rather than in memory, and it is useless if an attacker uses *process replacement*, which involves running a process on the system and overwriting its memory space with a malicious executable. It leaves a fingerprint: the image in memory will differ from the image on disk.
- One way to recognize process replacement is to use the Strings tab in the Process Properties window to compare the strings contained in the disk executable (image) against the strings in memory for that same executable running in memory.
- Process Explorer allows you to launch *depends.exe* (Dependency Walker) on a running process by right-clicking a process name and selecting `Launch` -> `Depends`. It also lets you search for a handle or DLL by choosing `Find` -> `Find Handle or DLL`.
- You can also use Process Explorer to analyze malicious documents, such as PDFs and Word documents. A quick way to determine whether a document is malicious is to open Process Explorer and then open the suspected malicious document. If the document launches any processes, you should see them in Process Explorer, and be able to locate the malware on disk via the Image tab of the Properties window.

### Comparing Registry Snapshots with Regshot

Regshot is an open source registry comparison tool that allows you to take and compare two registry snapshots. To use Regshot for malware analysis, simply take the first shot by clicking the `1st Shot` button, and then run the malware and wait for it to finish making any system changes. Next, take the second shot by clicking the `2nd Shot` button. Finally, click the `Compare` button to compare the two snapshots.

### Faking a Network

You can create a fake network and quickly obtain network indicators, without actually connecting to the Internet. These indicators can include DNS names, IP addresses, and packet signatures.

ApateDNS, a free tool from Mandiant (https://www.mandiant.com/products/research/mandiant_apatedns/download), is the quickest way to see DNS requests made by malware. ApateDNS spoofs NDS responses to a user-specified IP address by listening on UDP port 53 on the local machine. It responds to DNS requests with the DNS response set to an IP address you specify. ApateDNS can display the hexadecimal and ASCII results of all requests it receives.

Netcat can be used over both inbound and outbound connections for port scanning, tunneling, proxying, port forwarding, and much more. In listen mode, Netcat acts as a server, while in connect mode it acts as a client. Netcat takes data from standard input for transmission over the network. All the data it receives is output to the screen via standard output.

Wireshark is a network traffic sniffer, a packet capture tool that intercepts and logs network traffic on an interface. Wiresharek provides visualization, packet-stream analysis, and in-depth analysis of individual packets.

INetSim is a free, Linux-based software suite for simulating common Internet services.

### Basic Dynamic Tools in Practice

A basic setup may include the following:
1. Running procmon and setting a filter on the malware executable name and clearing out all events just before running.
2. Starting Process Explorer
3. Gathering a first snapshot of the registry using Regshot.
4. Setting up your virtual network to your liking using INetSim and ApateDNS.
5. Setting pu network traffic logging using Wireshark.
***

## Intel Assembly Basics

**Data Types and Sizes:**
  - **BIT**: The smallest possible piece of data. It can be either a 0 or a 1.
  - **NIBBLE**: 4 bits.
  - **BYTE**: A byte consists of 8 bits. It can have a maximal unsigned value of 0FFh (255d).
  - **WORD**: A word is just 2 bytes put together or 16 bits. A word can have a maximal unsigned value of 0FFFFh (65535d)
  - **DOUBLE WORD**: A double word is 2 words together or 32 bits. Maximum unsigned value of 0FFFFFFFFh (4294967295d).
  - **QUAD WORD**: A quad word is 4 words together or 64 bits.
  - **KILOBYTE**: Roughly 1000 bytes. There are 1024 (32 * 32) bytes in a kilobyte.
  - **MEGABYTE**: Roughly 1 million bytes. 1024 * 1024 or 1,048,578 bytes.

**Registers:** special places in a CPU where data is stored. On an Intel 32-bit CPU, there are 8 general purpose 32-bit registers and an IP register.
  - **EAX**: Extended Accumulator Register
  - **EBX**: Extended Base Register
  - **ECX**: Extended Counter Register
  - **EDX**: Extended Data Register
  - **ESI**: Extended Source Index
  - **EDI**: Extended Destination Index
  - **EBP**: Extended Base Pointer
  - **ESP**: Extended Stack Pointer
  - **EIP**: Extended Instruction Pointer
    - Generally, the size of the registers is 32-bits (4 bytes). They can hold data from 0 - 0xFFFFFFFF (unsigned).
    - **EBP**: EBP is mostly to do with stack and stack frames.
    - **ESP**: ESP points to the stack of a current process. The stack is the place where data can be stored for later use.
    - **EIP**: EIP always points to the next instruction that is to be executed.

The EAX, EBX, ECX, and EDX registers are 32-bit but their 16-bit and 8-bit sub-registers can be accessed as well.

| 32-bit Register | 16-bit Register | 8-bit Register |
| --------------- | --------------- | -------------- |
| EAX | AX | AH/AL |
| EBX | BX | BH/BL |
| ECX | CX | CH/CL |
| EDX | DX | DH/DL |
| ESI | SI | |
| EDI | DI | |
| EBP | BP | |
| ESP | SP | |
| EIP | IP | |

EAX is the name of the 32-bit register, AX is the name of the "Low Word" (16-bit) of EAX and AL/AH (8-bit) are the names of the "Low Byte" and "High Byte" of AX.

**Byte-Size Registers**: These registers are all exactly 1 byte in size. This does not mean the whole (32-bit) register is fully loaded with data.
- AL and AH
- BL and BH
- CL and CH
- DL and DH

**Word-Size Registers**: Are 1 word (2 bytes, 16 bits) in size. A word-sized register is constructed of 2 byte-sized registers.
- **General Purpose Registers**:
  - **AX (word-sized)**: AH + AL; AH and AL exist independently, but together they form AX. It is the accumulator, used in mathematical operations and stores strings.
  - **BX**: Base register, used in conjunction with the stack.
  - **CX**: Counter.
  - **DX**: Data operations, stores the remainder of mathematical operations.
  - **DI**: Destination index, used as a destination to copy strings.
  - **SI**: Source index, used as a source to copy strings from.
- **Index Registers**:
  - **BP**: Base pointer, points to a specified position on the stack.
  - **SP**: Stack pointer, points to a specified position on the stack.
- **Segment Registers**:
  - **CS**: Code segment, instructions as an application executes.
  - **DS**: Data segment, data needed by an application.
  - **ES**: Extra segment
  - **SS**: Stack segment, location of the stack.
- **Special Registers**:
  - **IP**: Instruction Pointer, points to the next instruction.
- **Doubleword-Size Registers**: 2 words, 4 bytes, 32 bits. (EAX, EBX, ECX, EDX, EDI)

**Segments and Offsets**: A segment is a piece in memory where instructions (CS), data (DS), the stack (SS), or just an extra segment (ES) aare stored. Every segment is divided in offsets. In 32-bit applications, these offsets are numbered from 00000000 to FFFFFFFF. 65536 pieces of memory thus 65536 memory address per segment.
- The standard notation for segments and offsets is: `SEGMENT     :     OFFSET    =     They point to an address`
- Another way to look at it:
  - A segment is a page in a book : An offset is a specific line on that page.

In traditional computer architecture, a computer system can be represented as several *levels of abstraction* that create a way of hiding the implementation details.

Malware authors create programs at the high-level language level and use a compiler to generate machine code to be run by the CPU. Conversely, malware analysts and reverse engineers operate at the low-level language level; we use a disassembler to generate assembly code that we can read and analyze to figure out how a program operates.

**Malware Author High-Level Language**
```
int c;
printf("Hello,\n");
exit(0);
```

**CPU Machine Code**
```
55
8B EC
8B EC 40
```

**Malware Analyst Low-Level Language**
```
push ebp
mov ebp, esp
sub esp, 0x40
```

### Six Levels of Abstraction

1. **Hardware**: The hardware level, the only physical level, consists of electrical circuits that implement complex combinations of logical operators such as `XOR`, `AND`, `OR`, and `NOT` gates, known as *digital logic*.
2. **Microcode**: The microcode level is also known as *firmware*. Microcode operates only on the exact circuitry for which it was designed.
3. **Machine code**: The machine code level consists of *opcodes*, hexadecimal digits that tell the processor what you want it to do.
4. **Low-level languages**: A low-level language is a human-readable version of a computer architecture's instruction set.
5. **High-level languages**: Most computer programmers operate at the level of high-level languages. High-level languages provide strong abstraction from the machine level and make it easy to use programming logic and flow-control mechanisms. These languages are typically turned into machine code by a compiler through a process known as *compilation*.
6. **Interpreted languages**: The code at this level is not compiled into machine code; instead, it is translated into bytecode. *Bytecode* is an intermediate representation that is specific to the programming language. Bytecode executes within an *interpreter*, which is a program that translates bytecode into executable machine code on the fly at runtime.

Assembly language is actually a class of languages. Each assembly dialect is typically used to program a single family of microprocessors, such as x86, x64, SPARC, PowerPC, MIPS, and ARM.

### The x86 Architecture

The internals of most modern computer architectures (including x86) follow the Von Neumann architecture. It has three hardware components:
1. The *central processing unit (CPU)* executes code.
2. The *main memory* of the system (RAM) stores all data and code.
3. An *input/output system (I/O)* interfaces with devices such as hard drives, keyboards, and monitors.

The CPU contains several components: The *control unit* gets instructions to execute from RAM using a *register* (the *instruction pointer*), which stores the address of the instruction to execute. Registers are the CPU's basic data storage units and are often used to save time so that the CPU doesn't need to access RAM. the *arithmetic logic unit (ALU)* executes an instruction fetched from RAM and places the results in registers or memory.

#### Main Memory

The main memory (RAM) for a single program can be divided into the following four major sections:
1. **Data**: This term can be used to refer to a specific section of memory called the *data section*, which contains values that are put in place when a program is initially loaded. These values are sometimes called *static* values because they may not change while the program is running, or they may be called *global* values because they are available to any part of the program.
2. **Code**: Code includes the instructions fetched by the CPU to execute the program's tasks. The code controls what the program does and how the program's tasks will be orchestrated.
3. **Heap**: The heap is used for dynamic memory during program execution, to create (allocate) new values and eliminate (free) values that the program no longer needs. The heap is referred to as *dynamic memory* because its contents can change frequently while the program is running.
4. **Stack**: The stack is used for local variables and parameters for functions, and to help control program flow.

#### Instructions

In x86 assembly, an instruction is made of a *mnemonic* and zero or more *operands*. A mnemonic is a word that identifies the instruction to execute. Operands are typically used to identify information used by the instruction, such as registers or data.

#### Opcodes and Endianness

Each instruction corresponds to *opcodes* (operation codes) that tell the CPU which operation the program wants to perform. The *endianness* of data describes whether the most significant (*big-endian*) or least significant (*little-endian*) byte is ordered first (at the smallest address) within a larger data item. Changing between endianness is something malware must do during network communication, becuase network data uses big-endian and an x86 program uses little-endian. Therefore, the IP address 127.0.0.1 will be represented as 0x7F000001 in big-endian format (over the network) and 0x0100007F in little-endian format (locally in memory).

#### Signedness

Each register value can be signed or unsigned
- If the most significant bit is set, the value is considered negative for signed operations.
- To know if a register value is signed:
  - Examine the sign flag (SF) in EFLAGS
  - SF also known as "negative flag"
- Examples:
  - 0x7f = 127 unsigned, 01111111 = 127 signed
  - 0x80 = 128 unsigned, 10000000 = -128 signed
  - 0xFF = 255 unsigned, 11111111 = -1 signed

#### Operands

Three types of operands can be used:
1. **Immediate** operands are fixed values, such as the `0x42`.
2. **Register** operands refer to registers, such as ECX.
3. **Memory address** operands refer to a memory address that contains the value of interest, typically denoted by a value, register, or equation between brackets, such as [eax].

#### Registers

A register is a small amount of data storage available to the CPU, whose contents can be accessed more quickly than storage available else ware.
- **General registers** are used by the CPU during execution. Typically, these store data or memory addresses, and are often used interchangeably to get things accomplished within the program.
  - EAX generally contains the return value for function calls. Therefore, if you see the EAX register used immediately after a function call, you are probably seeing the code manipulate the return value.
- **Segment registers** are used to track sections of memory
- **Status flags** are used to make decisions
- **Instruction pointers** are used to keep track of the next instruction to execute.

The `EFLAGS` register is a status register. In the x86 architecture, it is 32 bits in size, and each bit is a flag. During execution, each flag is either set (1) or cleared (0) to control CPU operations or indicate the results of a CPU operation. The following flags are most important to malware analysis:
- **ZF**: The zero flag is set when the result of an operation is equal to zero; otherwise, it is cleared.
- **CF**: The carry flag is set when the result of an operation is too large or too small for the destination operand; otherwise, it is cleared.
- **SF**: The sign flag is set when the result of an operation is negative or cleared when the result is positive. This flag is also set when the most significant bit is set after an arithmetic operation.
- **TF**: The trap flag is used for debugging. The x86 processor will execute only one instruction at a time if this flag is set.
- **OF**: The overflow flag is set (status: 1) when the last operation changed the highest bit of the register that gets the result of an operation. Another need for this flag to be set, is that the value of the destination register is neither 0 before the instruction nor after it.

In x86 architecture, EIP, also known as the *instruction pointer* or *program counter*, is a register that contains the memory address of the next instruction to be executed for a program. EIP's only purpose is to tell the processor what to do next.

#### Simple Instructions

`mov` is used to move data from one location to another. The `mov` instruction can move data into registers or RAM. The format is `mov destination, source`. (This is Intel syntax, where the destination is placed first).
- Memory addresses can be calculated when placed in square brackets. (`mov eax, [ebx+esi*4]`)

Another instruction similar to `mov` is `lea`, which means "load effective address". The format of the instruction is `lea destination, source`. The `lea` instruction is used to put a memory address into the destination. For example, `lea eax, [ebx+8]` wil put EBX+8 into EAX.

**INT**: generates a call to an interrupt handler. The destination value must be an integer.
- `int 21h`
- `int 3` and `int 4` are interrupt calls that take no parameters but call the handlers for interrupts 3 and 4, respectively.

#### Arithmetic

Addition or subtraction adds or subtracts a value from a destination operand. The format of the addition instruction is `add destination, value`. The format of the subtraction instruction is `sub destination, value`. The `sub` instruction modifies two important flags: the zero flag (ZF) and carry flag (CF).
- The `inc` and `dec` instructions increment or decrement a register by one.

Multiplication and division both act on a predefined register, so the command is simply the instruction, plus the value that the register will be multiplied or divided by. The format of the `mul` instruction is `mul value`. Similarly, the format of the `div` instruction is `div value`.
- The `mul value` instruction always multiplies `eax` by `value`. The result is stored as a 64-bit value across two registers: EDX and EAX. EDX stores the most significant 32-bits of the operations, and EAX stores the least significant 32 bits.
- The `div value` instruction does the same thing as `mul`, except in the opposite direction: it divides the 64-bits across EDX and EAX by value. The result of the division operation is stored in EAX, and the remainder is stored in EDX.

Logical operators such as OR, AND, and XOR are used in x86 architecture. They perform the specified operation between the source and destination operands and store the result in the destination. For example, `xor eax, eax` is a quick way to set the EAX register to zero. This is done for optimization, because this instruction requires only 2 bytes, whereas `mov eax, 0` requires 5 bytes.

The `shr` and `shl` instructions are used to shift registers. The format of the `shr` instruction is `shr destination, count`, and the `shl` instruction has the same format. The `shr` and `shl` instructions shift the bits in the destination operand to the right and left, respectively, by the number of bits specified in the count operand. Bits shifted beyond the destination boundary are first shifted into the CF flag. Zero bits are filled in during the shift.
- Shifting an operand to the left *n* bits multiplies it by 2^n.
- During malware analysis, if you encounter a function containing only the instructions `xor`, `or`, `and`, `shl`, `ror`, `shr`, or `rol` repeatedly and seemingly randomly, you have probably encountered an encryption or compression function.

#### NOP

The `nop` instruction does nothing. When it's issued, execution simply proceeds to the next instruction. The instruction `nop` is actually a pseudonym for `xchg eax, eax`, but since exchanging EAX with itself does nothing, it is popularly referred to as NOP (no operation).
- The opcode for this instruction is 0x90.

#### The Stack

Memory for functions, local variables, and flow control is stored in a `stack`, which is a data structure characterized by pushijng and popping. You push items onto the stack, and then pop those items off. A stack is a last in, first out (LIFO) structure. The x86 architecture has built-in support for a stack mechanism. The register support includes the ESP and EBP registers. ESP is the stack pointer and typically contains a memory address that points to the top of the stack. The value of this register changes as items are pushed on and popped off the stack. EBP is the base pointer that stays consistent within a given function, so that the program can use it as a placeholder to keep track of the location of local variables and parameters.
- The stack instructions include `push`, `pop`, `call`, `leave`, `enter`, and `ret`. The stack is allocated in a top-down format in memory, and the highest addresses are allocated and used first.
- The stack is used for short-term storage only. It frequently stores local variables, parameters, and the return address. Its primary usage is for the management of data exchanged between function calls.

#### Function Calls

*Functions* are portions of code within a program that perform a specific task and that are relatively independent of the remaining code. The most common function-writing convention is known as **cdecl**:
  - Many functions contain a *prologue* -- a few lines of code at the start of the function. The prologue prepares the stack and registers for use within the function. In the same vein, an *epilogue* at the end of a function restores the stack and registers to their state before the function was called.

Functions are organized and executed using the steps below:
1. Arguments are placed on the stack using `push` instructions.
2. A function is called using `call memory_location`. This causes the current instruction address (that is, the contents of the EIP register) to be pushed onto the stack. This address will be used to return to the main code when the function is finished. When the function begins, EIP is set to `memory_location` (the start of the function).
3. Through the use of a function prologue, space is allocated on the stack for local variables and EBP (the base pointer) is pushed onto the stack. This is done to save EBP for the calling function.
4. The function performs its work.
5. Through the use of a function epilogue, the stack is restored. ESP is adjusted to free the local variables, and EBP is restored so that the calling function can address is variables properly. The `leave` instruction can be used as an epilogue because it sets ESP to equal EBP and pops EBP off the stack.
6. The function returns by calling the `ret` instruction. This pops the return address off the stack and into EIP, so that the program will continue executing from where the original call was made.
7. The stack is adjusted to remove the arguments that were sent, unless they'll be used again later.

#### Stack Layout

Each time a call is performed, a new stack from is generated. A function maintains its own stack frame until it returns, at which time the caller's stack frame is restored and execution is transferred back to the calling function.

It is possible to read data from the stack without using the `push` or `pop` instructions. For example, the instruction `mov eax, ss:[esp]` will directly access the top of the stack. This is identical to `pop eax`, except the ESP register is not impacted.

The x86 architecture provides additional instructions for popping and pushing, the most popular of which are `pusha` and `pushad`. These instructions push all the registers onto the stack and are commonly used with `popa` and `popad`, which pop all the registers off the stack. The `pusha` and `pushad` functions operate as follows:
- `pusha` pushes the 16-bit registers on the stack in the following order: AX, CX, DX, BX, SP, BP, SI, DI
- `pushad` pushes the 32-bit registers on the stack in the following order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
- These instructions are typically encountered in shellcode when someone wants to save the current state of the registers to the stack so that they can be restored at a later time. Compilers rarely use these instructions, so seeing them often indicates someone hand-coded assembly and/or shellcode.

#### Conditionals

*Conditionals* are instructions that perform comparisons. The two most popular conditional instructions are `test` and `cmp`. The `test` instruction is identical to the `and` instruction; however, the operands involved are not modified by the instruction. The `test` instruction only sets the flags. The zero flag (ZF) is typically the flag of interest after the `test` instruction. A test of something against itself is often used to check for NULL values.

The `cmp` instruction is identical to the `sub` instruction; however, the operands are not affected. The `cmp` instruction is used only to set the flags. The zero flag and carry flag (CF) may be changed as a result of the `cmp` instruction.

| cmp dst, src | ZF | CF |
| ------------ | -- | -- |
| dst = src | 1 | 0 |
| dst < src | 0 | 1 |
| dst > src | 0 | 0 |

#### Branching

A *branch* is a sequence of code that is conditionally executed depending on the flow of the program. The term *branching* is used to describe the control flow through the branches of a program.
- The most popular way branching occurs is with *jump instructions*.
- The format `jmp location` causes the next instruction executed to be the one specified by the `jmp`. This is known as an *unconditional* jump, because execution will always transfer to the target location.
- Jump Conditional Code (JCC) is the shorthand for generally describing conditional jumps.

| Instruction | Description |
| ----------- | ----------- |
| jz loc | Jump to specified location if ZF = 1 |
| jnz loc | Jump to specified location if ZF = 0 |
| je loc | Same as jz, but commonly used after a cmp instruction. Jump will occur if the destination operand equals the source operand. |
| jne loc | Same as jnz, but commonly used after a cmp. Jump will occur if the destination operand is not equal to the source operand. |
| jg loc | Performs signed comparison jump after a cmp if the destination operand is greater than the source operand. |
| jge loc | Performs signed comparison jump after a cmp if the destination operand is greater than or equal to the source operand. |
| ja loc | Same as jg, but an unsigned comparison is performed. |
| jae loc | Same as jge, but an unsigned comparison is performed. |
| jl loc | Performs signed comparison jump after a cmp if the destination operand is less than the source operand. |
| jle loc | Performs signed comparison jump after a cmp if the destination operand is less than or equal to the source operand. |
| jb loc | Same as jl, but an unsigned comparison is perfomed. |
| jbe loc | Same as jle, but an unsigned comparison is perfomed. |
| jo loc | Jump if the previous instruction set the overflow flag (OF = 1) |
| js loc | Jump if the sign flag is set (SF = 1). |
| jecxz loc | Jump to location if ECX = 0. |

#### Rep Instructions

*Rep instructions* are a set of instructions for manipulating data buffers. They are usually in the form of an array of bytes, but they can also be single or double words. The most common data buffer manipulation instructions are `movsx`, `cmpsx`, `stosx`, and `scasx`, where `x` = `b`, `w`, or `d` for byte, word, or double word, respectfully.
- The ESI and EDI registers are used in these operations. ESI is the source index register, and EDI is the destination index register. ECX is used as the counting variable.
- These instructions require a prefix to operate on data lengths greater than 1. The `movsb` instruction will move only a single byte and does not utilize the ECX register.
- In x86, the repeat prefixes are used for multibyte operations. The `rep` instruction increments the ESI and EDI offsets, and decrements the ECX register. The `rep` prefix will continue until ECX = 0. The `repe`/`repz` and `repne`/`repnz` prefixes will continue until ECX = 0 or until the ZF = 1 or 0.

| Instruction | Description |
| ----------- | ----------- |
| rep | Repeat until ECX = 0 |
| repe, repz | Repeat until ECX = 0 or ZF = 0 |
| repne, repnz | Repeat until ECX = 0 or ZF = 1 |

The `movsb` instruction is used to move a sequence of bytes from one location to another. The `rep` prefix is commonly used with `movsb` to copy a sequence of bytes, with size defined by ECX. The `rep movsb` instruction is the logical equivalent of the C `memcopy` function. The `movsb` instruction grabs the byte at address ESI, stores it at address EDI, and then increments or decrements the ESI and EDI registers by one according to the setting of the direction flag (DF). If DF = 0, they are incremented; otherwise, they are decremented.

The `cmpsb` instruction is used to compare two sequences of bytes to determine whether they contain the same data. The `cmpsb` instruction subtracts the value at location EDI from the value at ESI and updates the flags. It is typically used with the `repe` prefix. When coupled with the `repe` prefix, the `cmpsb` instruction compares each byte of the two sequences until it finds a difference between the sequences or reaches the end of the comparison. The `cmpsb` instruction obtains the byte at address ESI, compares the value at location EDI to set the flags, and then increments the ESI and EDI register by one. If the `repe` prefix is present, ECX is checked and the flags are also checked, but if ECX = 0 or ZF = 0, the operation will stop repeating. This is equivalent to the C functio `memcmp`.

The `scasb` instruction is used to search for a single value in a sequence of bytes. The value is defined by the AL register. This works in the same way as `cmpsb`, but it compares the byte located at address EDI to AL, rather than to ESI. The `repe` operation will continue until the byte is found or ECX = 0. If the value is found in the sequence of bytes, ESI stores the location of that value.

The `stosb` instruction is used to store values in a location specified by EDI. This is identical to `scasb`, but instead of being searched for, the specified byte is placed in the location specified by EDI. The `rep` prefix is used with `scasb` to initialize a buffer of memory, wherein every byte contains the same value. This is equivalent to the C function `memset`.

| Instruction | Description |
| ----------- | ----------- |
| repe cmpsb | Used to compare two data buffers. EDI and ESI must be set to the two buffer locations, and ECX must be set to the buffer length. The comparison will continue until ECX = 0 or the buffers are not equal. |
| rep stosb | Used to initialize all bytes of a buffer to a certain value. EDI will contain the buffer location, and AL must contain the initialization value. This instruction is often seen used with `xor eax, eax`. |
| rep movsb | Typically used to copy a buffer of bytes. ESI must be set to the source buffer address, EDI must be set to the destination buffer address, and ECX must contain the length to copy. Byte-by-byte copy will continue until ECX = 0. |
| repne scasb | Used for searching a data buffer for a single byte. EDI must contain the address of the buffer, AL must contain the byte you are looking for, and ECX must be set to the buffer length. The comparison will continue until ECX = 0 or until the byte is found. |

### Assembly Basics

**An Assembly program has three basic sections:**
1. The `data` section: Used for declaring initialized data or constants, (data that does not change at runtime).
  - Used to declare various constant values, file names, or buffer sizes, etc.
  - Syntax for declaring the data section is: `section.data`.
2. The `bss` section: used for declaring variables.
  - Syntax for declaring the bss section is: `section.bss`
3. The `text` section: used for keeping the actual code.
  - Must begin with the declaration `global _start`, which tells the kernel where the program execution begins.
  - The syntax for declaring the text section is:
    ```
    section.text
      global _start
    _start:
    ```

**Comments**:
- Declared with a semicolon (;).
  - `add eax, ebx   ; adds ebx to eax`

**Assembly Language Statements**:

***
